import pandas

# Считайте таблицу с признаками из файла features.csv с помощью кода, приведенного выше. Удалите признаки,
# связанные с итогами матча (они помечены в описании данных как отсутствующие в тестовой выборке).
data = pandas.read_csv('features.csv')
result_columns_names = ['duration', 'radiant_win', 'tower_status_radiant',
                        'tower_status_dire', 'barracks_status_radiant', 'barracks_status_dire']
result = data[result_columns_names]
data = data.drop(result_columns_names, axis=1)

# Проверьте выборку на наличие пропусков с помощью функции count(), которая для каждого столбца показывает число
# заполненных значений. Много ли пропусков в данных? Запишите названия признаков, имеющих пропуски, и попробуйте для
# любых двух из них дать обоснование, почему их значения могут быть пропущены.
# некоторые события не случились за 5 минут
# print(data.count()[data.count() != 97230])
# print(data.isnull().sum()[data.isnull().sum() != 0] )

# Замените пропуски на нули с помощью функции fillna(). На самом деле этот способ является предпочтительным для
# логистической регрессии, поскольку он позволит пропущенному значению не вносить никакого вклада в предсказание. Для
#  деревьев часто лучшим вариантом оказывается замена пропуска на очень большое или очень маленькое значение — в этом
#  случае при построении разбиения вершины можно будет отправить объекты с пропусками в отдельную ветвь дерева. Также
#  есть и другие подходы — например, замена пропуска на среднее значение признака. Мы не требуем этого в задании,
# но при желании попробуйте разные подходы к обработке пропусков и сравните их между собой.



# print(data['match_id'].value_counts())
